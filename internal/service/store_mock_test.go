// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"context"
	dbgen "github.com/cornelmarck/durable-execution/internal/db/gen"
	"github.com/jackc/pgx/v5/pgtype"
	"sync"
)

// Ensure, that StoreMock does implement Store.
// If this is not the case, regenerate this file with moq.
var _ Store = &StoreMock{}

// StoreMock is a mock implementation of Store.
//
//	func TestSomethingThatUsesStore(t *testing.T) {
//
//		// make and configure a mocked Store
//		mockedStore := &StoreMock{
//			ClaimRunsFunc: func(ctx context.Context, arg dbgen.ClaimRunsParams) ([]dbgen.ClaimRunsRow, error) {
//				panic("mock out the ClaimRuns method")
//			},
//			CleanupCompletedRunsFunc: func(ctx context.Context, ttlSeconds int32) error {
//				panic("mock out the CleanupCompletedRuns method")
//			},
//			CleanupEventsFunc: func(ctx context.Context, ttlSeconds int32) error {
//				panic("mock out the CleanupEvents method")
//			},
//			CompleteRunFunc: func(ctx context.Context, arg dbgen.CompleteRunParams) error {
//				panic("mock out the CompleteRun method")
//			},
//			CountQueuesFunc: func(ctx context.Context) (int64, error) {
//				panic("mock out the CountQueues method")
//			},
//			CreateEventFunc: func(ctx context.Context, arg dbgen.CreateEventParams) (dbgen.Event, error) {
//				panic("mock out the CreateEvent method")
//			},
//			CreateQueueFunc: func(ctx context.Context, arg dbgen.CreateQueueParams) (dbgen.Queue, error) {
//				panic("mock out the CreateQueue method")
//			},
//			CreateRunFunc: func(ctx context.Context, arg dbgen.CreateRunParams) (dbgen.Run, error) {
//				panic("mock out the CreateRun method")
//			},
//			CreateTaskFunc: func(ctx context.Context, arg dbgen.CreateTaskParams) (pgtype.UUID, error) {
//				panic("mock out the CreateTask method")
//			},
//			CreateWorkflowRunFunc: func(ctx context.Context, arg dbgen.CreateWorkflowRunParams) (dbgen.WorkflowRun, error) {
//				panic("mock out the CreateWorkflowRun method")
//			},
//			DeleteQueueFunc: func(ctx context.Context, id pgtype.UUID) error {
//				panic("mock out the DeleteQueue method")
//			},
//			ExecTxFunc: func(ctx context.Context, fn func(dbgen.Querier) error) error {
//				panic("mock out the ExecTx method")
//			},
//			ExpireTimedOutWaitersFunc: func(ctx context.Context) ([]dbgen.Run, error) {
//				panic("mock out the ExpireTimedOutWaiters method")
//			},
//			ExtendRunClaimFunc: func(ctx context.Context, arg dbgen.ExtendRunClaimParams) error {
//				panic("mock out the ExtendRunClaim method")
//			},
//			FailRunFunc: func(ctx context.Context, arg dbgen.FailRunParams) error {
//				panic("mock out the FailRun method")
//			},
//			GetCheckpointFunc: func(ctx context.Context, arg dbgen.GetCheckpointParams) (dbgen.Checkpoint, error) {
//				panic("mock out the GetCheckpoint method")
//			},
//			GetEventByNameFunc: func(ctx context.Context, eventName string) (dbgen.Event, error) {
//				panic("mock out the GetEventByName method")
//			},
//			GetQueueByNameFunc: func(ctx context.Context, name string) (dbgen.Queue, error) {
//				panic("mock out the GetQueueByName method")
//			},
//			GetQueueStatsFunc: func(ctx context.Context, queueID pgtype.UUID) (dbgen.GetQueueStatsRow, error) {
//				panic("mock out the GetQueueStats method")
//			},
//			GetRunFunc: func(ctx context.Context, id pgtype.UUID) (dbgen.Run, error) {
//				panic("mock out the GetRun method")
//			},
//			GetRunsByTaskFunc: func(ctx context.Context, taskID pgtype.UUID) ([]dbgen.Run, error) {
//				panic("mock out the GetRunsByTask method")
//			},
//			GetTaskFunc: func(ctx context.Context, id pgtype.UUID) (dbgen.Task, error) {
//				panic("mock out the GetTask method")
//			},
//			GetWorkflowRunFunc: func(ctx context.Context, id pgtype.UUID) (dbgen.WorkflowRun, error) {
//				panic("mock out the GetWorkflowRun method")
//			},
//			ListQueuesFunc: func(ctx context.Context) ([]dbgen.Queue, error) {
//				panic("mock out the ListQueues method")
//			},
//			ListTasksFunc: func(ctx context.Context, arg dbgen.ListTasksParams) ([]dbgen.ListTasksRow, error) {
//				panic("mock out the ListTasks method")
//			},
//			ScheduleRunFunc: func(ctx context.Context, arg dbgen.ScheduleRunParams) error {
//				panic("mock out the ScheduleRun method")
//			},
//			SetRunSleepingFunc: func(ctx context.Context, arg dbgen.SetRunSleepingParams) error {
//				panic("mock out the SetRunSleeping method")
//			},
//			UpdateTaskStatusFunc: func(ctx context.Context, arg dbgen.UpdateTaskStatusParams) error {
//				panic("mock out the UpdateTaskStatus method")
//			},
//			UpdateWorkflowRunFunc: func(ctx context.Context, arg dbgen.UpdateWorkflowRunParams) (dbgen.WorkflowRun, error) {
//				panic("mock out the UpdateWorkflowRun method")
//			},
//			UpsertCheckpointFunc: func(ctx context.Context, arg dbgen.UpsertCheckpointParams) (dbgen.Checkpoint, error) {
//				panic("mock out the UpsertCheckpoint method")
//			},
//			WakeRunsByEventFunc: func(ctx context.Context, waitingEventName pgtype.Text) ([]dbgen.Run, error) {
//				panic("mock out the WakeRunsByEvent method")
//			},
//		}
//
//		// use mockedStore in code that requires Store
//		// and then make assertions.
//
//	}
type StoreMock struct {
	// ClaimRunsFunc mocks the ClaimRuns method.
	ClaimRunsFunc func(ctx context.Context, arg dbgen.ClaimRunsParams) ([]dbgen.ClaimRunsRow, error)

	// CleanupCompletedRunsFunc mocks the CleanupCompletedRuns method.
	CleanupCompletedRunsFunc func(ctx context.Context, ttlSeconds int32) error

	// CleanupEventsFunc mocks the CleanupEvents method.
	CleanupEventsFunc func(ctx context.Context, ttlSeconds int32) error

	// CompleteRunFunc mocks the CompleteRun method.
	CompleteRunFunc func(ctx context.Context, arg dbgen.CompleteRunParams) error

	// CountQueuesFunc mocks the CountQueues method.
	CountQueuesFunc func(ctx context.Context) (int64, error)

	// CreateEventFunc mocks the CreateEvent method.
	CreateEventFunc func(ctx context.Context, arg dbgen.CreateEventParams) (dbgen.Event, error)

	// CreateQueueFunc mocks the CreateQueue method.
	CreateQueueFunc func(ctx context.Context, arg dbgen.CreateQueueParams) (dbgen.Queue, error)

	// CreateRunFunc mocks the CreateRun method.
	CreateRunFunc func(ctx context.Context, arg dbgen.CreateRunParams) (dbgen.Run, error)

	// CreateTaskFunc mocks the CreateTask method.
	CreateTaskFunc func(ctx context.Context, arg dbgen.CreateTaskParams) (pgtype.UUID, error)

	// CreateWorkflowRunFunc mocks the CreateWorkflowRun method.
	CreateWorkflowRunFunc func(ctx context.Context, arg dbgen.CreateWorkflowRunParams) (dbgen.WorkflowRun, error)

	// DeleteQueueFunc mocks the DeleteQueue method.
	DeleteQueueFunc func(ctx context.Context, id pgtype.UUID) error

	// ExecTxFunc mocks the ExecTx method.
	ExecTxFunc func(ctx context.Context, fn func(dbgen.Querier) error) error

	// ExpireTimedOutWaitersFunc mocks the ExpireTimedOutWaiters method.
	ExpireTimedOutWaitersFunc func(ctx context.Context) ([]dbgen.Run, error)

	// ExtendRunClaimFunc mocks the ExtendRunClaim method.
	ExtendRunClaimFunc func(ctx context.Context, arg dbgen.ExtendRunClaimParams) error

	// FailRunFunc mocks the FailRun method.
	FailRunFunc func(ctx context.Context, arg dbgen.FailRunParams) error

	// GetCheckpointFunc mocks the GetCheckpoint method.
	GetCheckpointFunc func(ctx context.Context, arg dbgen.GetCheckpointParams) (dbgen.Checkpoint, error)

	// GetEventByNameFunc mocks the GetEventByName method.
	GetEventByNameFunc func(ctx context.Context, eventName string) (dbgen.Event, error)

	// GetQueueByNameFunc mocks the GetQueueByName method.
	GetQueueByNameFunc func(ctx context.Context, name string) (dbgen.Queue, error)

	// GetQueueStatsFunc mocks the GetQueueStats method.
	GetQueueStatsFunc func(ctx context.Context, queueID pgtype.UUID) (dbgen.GetQueueStatsRow, error)

	// GetRunFunc mocks the GetRun method.
	GetRunFunc func(ctx context.Context, id pgtype.UUID) (dbgen.Run, error)

	// GetRunsByTaskFunc mocks the GetRunsByTask method.
	GetRunsByTaskFunc func(ctx context.Context, taskID pgtype.UUID) ([]dbgen.Run, error)

	// GetTaskFunc mocks the GetTask method.
	GetTaskFunc func(ctx context.Context, id pgtype.UUID) (dbgen.Task, error)

	// GetWorkflowRunFunc mocks the GetWorkflowRun method.
	GetWorkflowRunFunc func(ctx context.Context, id pgtype.UUID) (dbgen.WorkflowRun, error)

	// ListQueuesFunc mocks the ListQueues method.
	ListQueuesFunc func(ctx context.Context) ([]dbgen.Queue, error)

	// ListTasksFunc mocks the ListTasks method.
	ListTasksFunc func(ctx context.Context, arg dbgen.ListTasksParams) ([]dbgen.ListTasksRow, error)

	// ScheduleRunFunc mocks the ScheduleRun method.
	ScheduleRunFunc func(ctx context.Context, arg dbgen.ScheduleRunParams) error

	// SetRunSleepingFunc mocks the SetRunSleeping method.
	SetRunSleepingFunc func(ctx context.Context, arg dbgen.SetRunSleepingParams) error

	// UpdateTaskStatusFunc mocks the UpdateTaskStatus method.
	UpdateTaskStatusFunc func(ctx context.Context, arg dbgen.UpdateTaskStatusParams) error

	// UpdateWorkflowRunFunc mocks the UpdateWorkflowRun method.
	UpdateWorkflowRunFunc func(ctx context.Context, arg dbgen.UpdateWorkflowRunParams) (dbgen.WorkflowRun, error)

	// UpsertCheckpointFunc mocks the UpsertCheckpoint method.
	UpsertCheckpointFunc func(ctx context.Context, arg dbgen.UpsertCheckpointParams) (dbgen.Checkpoint, error)

	// WakeRunsByEventFunc mocks the WakeRunsByEvent method.
	WakeRunsByEventFunc func(ctx context.Context, waitingEventName pgtype.Text) ([]dbgen.Run, error)

	// calls tracks calls to the methods.
	calls struct {
		// ClaimRuns holds details about calls to the ClaimRuns method.
		ClaimRuns []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.ClaimRunsParams
		}
		// CleanupCompletedRuns holds details about calls to the CleanupCompletedRuns method.
		CleanupCompletedRuns []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TtlSeconds is the ttlSeconds argument value.
			TtlSeconds int32
		}
		// CleanupEvents holds details about calls to the CleanupEvents method.
		CleanupEvents []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TtlSeconds is the ttlSeconds argument value.
			TtlSeconds int32
		}
		// CompleteRun holds details about calls to the CompleteRun method.
		CompleteRun []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.CompleteRunParams
		}
		// CountQueues holds details about calls to the CountQueues method.
		CountQueues []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CreateEvent holds details about calls to the CreateEvent method.
		CreateEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.CreateEventParams
		}
		// CreateQueue holds details about calls to the CreateQueue method.
		CreateQueue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.CreateQueueParams
		}
		// CreateRun holds details about calls to the CreateRun method.
		CreateRun []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.CreateRunParams
		}
		// CreateTask holds details about calls to the CreateTask method.
		CreateTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.CreateTaskParams
		}
		// CreateWorkflowRun holds details about calls to the CreateWorkflowRun method.
		CreateWorkflowRun []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.CreateWorkflowRunParams
		}
		// DeleteQueue holds details about calls to the DeleteQueue method.
		DeleteQueue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// ExecTx holds details about calls to the ExecTx method.
		ExecTx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Fn is the fn argument value.
			Fn func(dbgen.Querier) error
		}
		// ExpireTimedOutWaiters holds details about calls to the ExpireTimedOutWaiters method.
		ExpireTimedOutWaiters []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ExtendRunClaim holds details about calls to the ExtendRunClaim method.
		ExtendRunClaim []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.ExtendRunClaimParams
		}
		// FailRun holds details about calls to the FailRun method.
		FailRun []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.FailRunParams
		}
		// GetCheckpoint holds details about calls to the GetCheckpoint method.
		GetCheckpoint []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.GetCheckpointParams
		}
		// GetEventByName holds details about calls to the GetEventByName method.
		GetEventByName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// EventName is the eventName argument value.
			EventName string
		}
		// GetQueueByName holds details about calls to the GetQueueByName method.
		GetQueueByName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// GetQueueStats holds details about calls to the GetQueueStats method.
		GetQueueStats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// QueueID is the queueID argument value.
			QueueID pgtype.UUID
		}
		// GetRun holds details about calls to the GetRun method.
		GetRun []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetRunsByTask holds details about calls to the GetRunsByTask method.
		GetRunsByTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TaskID is the taskID argument value.
			TaskID pgtype.UUID
		}
		// GetTask holds details about calls to the GetTask method.
		GetTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetWorkflowRun holds details about calls to the GetWorkflowRun method.
		GetWorkflowRun []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// ListQueues holds details about calls to the ListQueues method.
		ListQueues []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListTasks holds details about calls to the ListTasks method.
		ListTasks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.ListTasksParams
		}
		// ScheduleRun holds details about calls to the ScheduleRun method.
		ScheduleRun []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.ScheduleRunParams
		}
		// SetRunSleeping holds details about calls to the SetRunSleeping method.
		SetRunSleeping []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.SetRunSleepingParams
		}
		// UpdateTaskStatus holds details about calls to the UpdateTaskStatus method.
		UpdateTaskStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.UpdateTaskStatusParams
		}
		// UpdateWorkflowRun holds details about calls to the UpdateWorkflowRun method.
		UpdateWorkflowRun []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.UpdateWorkflowRunParams
		}
		// UpsertCheckpoint holds details about calls to the UpsertCheckpoint method.
		UpsertCheckpoint []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg dbgen.UpsertCheckpointParams
		}
		// WakeRunsByEvent holds details about calls to the WakeRunsByEvent method.
		WakeRunsByEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WaitingEventName is the waitingEventName argument value.
			WaitingEventName pgtype.Text
		}
	}
	lockClaimRuns             sync.RWMutex
	lockCleanupCompletedRuns  sync.RWMutex
	lockCleanupEvents         sync.RWMutex
	lockCompleteRun           sync.RWMutex
	lockCountQueues           sync.RWMutex
	lockCreateEvent           sync.RWMutex
	lockCreateQueue           sync.RWMutex
	lockCreateRun             sync.RWMutex
	lockCreateTask            sync.RWMutex
	lockCreateWorkflowRun     sync.RWMutex
	lockDeleteQueue           sync.RWMutex
	lockExecTx                sync.RWMutex
	lockExpireTimedOutWaiters sync.RWMutex
	lockExtendRunClaim        sync.RWMutex
	lockFailRun               sync.RWMutex
	lockGetCheckpoint         sync.RWMutex
	lockGetEventByName        sync.RWMutex
	lockGetQueueByName        sync.RWMutex
	lockGetQueueStats         sync.RWMutex
	lockGetRun                sync.RWMutex
	lockGetRunsByTask         sync.RWMutex
	lockGetTask               sync.RWMutex
	lockGetWorkflowRun        sync.RWMutex
	lockListQueues            sync.RWMutex
	lockListTasks             sync.RWMutex
	lockScheduleRun           sync.RWMutex
	lockSetRunSleeping        sync.RWMutex
	lockUpdateTaskStatus      sync.RWMutex
	lockUpdateWorkflowRun     sync.RWMutex
	lockUpsertCheckpoint      sync.RWMutex
	lockWakeRunsByEvent       sync.RWMutex
}

// ClaimRuns calls ClaimRunsFunc.
func (mock *StoreMock) ClaimRuns(ctx context.Context, arg dbgen.ClaimRunsParams) ([]dbgen.ClaimRunsRow, error) {
	if mock.ClaimRunsFunc == nil {
		panic("StoreMock.ClaimRunsFunc: method is nil but Store.ClaimRuns was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.ClaimRunsParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockClaimRuns.Lock()
	mock.calls.ClaimRuns = append(mock.calls.ClaimRuns, callInfo)
	mock.lockClaimRuns.Unlock()
	return mock.ClaimRunsFunc(ctx, arg)
}

// ClaimRunsCalls gets all the calls that were made to ClaimRuns.
// Check the length with:
//
//	len(mockedStore.ClaimRunsCalls())
func (mock *StoreMock) ClaimRunsCalls() []struct {
	Ctx context.Context
	Arg dbgen.ClaimRunsParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.ClaimRunsParams
	}
	mock.lockClaimRuns.RLock()
	calls = mock.calls.ClaimRuns
	mock.lockClaimRuns.RUnlock()
	return calls
}

// CleanupCompletedRuns calls CleanupCompletedRunsFunc.
func (mock *StoreMock) CleanupCompletedRuns(ctx context.Context, ttlSeconds int32) error {
	if mock.CleanupCompletedRunsFunc == nil {
		panic("StoreMock.CleanupCompletedRunsFunc: method is nil but Store.CleanupCompletedRuns was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		TtlSeconds int32
	}{
		Ctx:        ctx,
		TtlSeconds: ttlSeconds,
	}
	mock.lockCleanupCompletedRuns.Lock()
	mock.calls.CleanupCompletedRuns = append(mock.calls.CleanupCompletedRuns, callInfo)
	mock.lockCleanupCompletedRuns.Unlock()
	return mock.CleanupCompletedRunsFunc(ctx, ttlSeconds)
}

// CleanupCompletedRunsCalls gets all the calls that were made to CleanupCompletedRuns.
// Check the length with:
//
//	len(mockedStore.CleanupCompletedRunsCalls())
func (mock *StoreMock) CleanupCompletedRunsCalls() []struct {
	Ctx        context.Context
	TtlSeconds int32
} {
	var calls []struct {
		Ctx        context.Context
		TtlSeconds int32
	}
	mock.lockCleanupCompletedRuns.RLock()
	calls = mock.calls.CleanupCompletedRuns
	mock.lockCleanupCompletedRuns.RUnlock()
	return calls
}

// CleanupEvents calls CleanupEventsFunc.
func (mock *StoreMock) CleanupEvents(ctx context.Context, ttlSeconds int32) error {
	if mock.CleanupEventsFunc == nil {
		panic("StoreMock.CleanupEventsFunc: method is nil but Store.CleanupEvents was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		TtlSeconds int32
	}{
		Ctx:        ctx,
		TtlSeconds: ttlSeconds,
	}
	mock.lockCleanupEvents.Lock()
	mock.calls.CleanupEvents = append(mock.calls.CleanupEvents, callInfo)
	mock.lockCleanupEvents.Unlock()
	return mock.CleanupEventsFunc(ctx, ttlSeconds)
}

// CleanupEventsCalls gets all the calls that were made to CleanupEvents.
// Check the length with:
//
//	len(mockedStore.CleanupEventsCalls())
func (mock *StoreMock) CleanupEventsCalls() []struct {
	Ctx        context.Context
	TtlSeconds int32
} {
	var calls []struct {
		Ctx        context.Context
		TtlSeconds int32
	}
	mock.lockCleanupEvents.RLock()
	calls = mock.calls.CleanupEvents
	mock.lockCleanupEvents.RUnlock()
	return calls
}

// CompleteRun calls CompleteRunFunc.
func (mock *StoreMock) CompleteRun(ctx context.Context, arg dbgen.CompleteRunParams) error {
	if mock.CompleteRunFunc == nil {
		panic("StoreMock.CompleteRunFunc: method is nil but Store.CompleteRun was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.CompleteRunParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockCompleteRun.Lock()
	mock.calls.CompleteRun = append(mock.calls.CompleteRun, callInfo)
	mock.lockCompleteRun.Unlock()
	return mock.CompleteRunFunc(ctx, arg)
}

// CompleteRunCalls gets all the calls that were made to CompleteRun.
// Check the length with:
//
//	len(mockedStore.CompleteRunCalls())
func (mock *StoreMock) CompleteRunCalls() []struct {
	Ctx context.Context
	Arg dbgen.CompleteRunParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.CompleteRunParams
	}
	mock.lockCompleteRun.RLock()
	calls = mock.calls.CompleteRun
	mock.lockCompleteRun.RUnlock()
	return calls
}

// CountQueues calls CountQueuesFunc.
func (mock *StoreMock) CountQueues(ctx context.Context) (int64, error) {
	if mock.CountQueuesFunc == nil {
		panic("StoreMock.CountQueuesFunc: method is nil but Store.CountQueues was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCountQueues.Lock()
	mock.calls.CountQueues = append(mock.calls.CountQueues, callInfo)
	mock.lockCountQueues.Unlock()
	return mock.CountQueuesFunc(ctx)
}

// CountQueuesCalls gets all the calls that were made to CountQueues.
// Check the length with:
//
//	len(mockedStore.CountQueuesCalls())
func (mock *StoreMock) CountQueuesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCountQueues.RLock()
	calls = mock.calls.CountQueues
	mock.lockCountQueues.RUnlock()
	return calls
}

// CreateEvent calls CreateEventFunc.
func (mock *StoreMock) CreateEvent(ctx context.Context, arg dbgen.CreateEventParams) (dbgen.Event, error) {
	if mock.CreateEventFunc == nil {
		panic("StoreMock.CreateEventFunc: method is nil but Store.CreateEvent was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.CreateEventParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockCreateEvent.Lock()
	mock.calls.CreateEvent = append(mock.calls.CreateEvent, callInfo)
	mock.lockCreateEvent.Unlock()
	return mock.CreateEventFunc(ctx, arg)
}

// CreateEventCalls gets all the calls that were made to CreateEvent.
// Check the length with:
//
//	len(mockedStore.CreateEventCalls())
func (mock *StoreMock) CreateEventCalls() []struct {
	Ctx context.Context
	Arg dbgen.CreateEventParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.CreateEventParams
	}
	mock.lockCreateEvent.RLock()
	calls = mock.calls.CreateEvent
	mock.lockCreateEvent.RUnlock()
	return calls
}

// CreateQueue calls CreateQueueFunc.
func (mock *StoreMock) CreateQueue(ctx context.Context, arg dbgen.CreateQueueParams) (dbgen.Queue, error) {
	if mock.CreateQueueFunc == nil {
		panic("StoreMock.CreateQueueFunc: method is nil but Store.CreateQueue was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.CreateQueueParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockCreateQueue.Lock()
	mock.calls.CreateQueue = append(mock.calls.CreateQueue, callInfo)
	mock.lockCreateQueue.Unlock()
	return mock.CreateQueueFunc(ctx, arg)
}

// CreateQueueCalls gets all the calls that were made to CreateQueue.
// Check the length with:
//
//	len(mockedStore.CreateQueueCalls())
func (mock *StoreMock) CreateQueueCalls() []struct {
	Ctx context.Context
	Arg dbgen.CreateQueueParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.CreateQueueParams
	}
	mock.lockCreateQueue.RLock()
	calls = mock.calls.CreateQueue
	mock.lockCreateQueue.RUnlock()
	return calls
}

// CreateRun calls CreateRunFunc.
func (mock *StoreMock) CreateRun(ctx context.Context, arg dbgen.CreateRunParams) (dbgen.Run, error) {
	if mock.CreateRunFunc == nil {
		panic("StoreMock.CreateRunFunc: method is nil but Store.CreateRun was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.CreateRunParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockCreateRun.Lock()
	mock.calls.CreateRun = append(mock.calls.CreateRun, callInfo)
	mock.lockCreateRun.Unlock()
	return mock.CreateRunFunc(ctx, arg)
}

// CreateRunCalls gets all the calls that were made to CreateRun.
// Check the length with:
//
//	len(mockedStore.CreateRunCalls())
func (mock *StoreMock) CreateRunCalls() []struct {
	Ctx context.Context
	Arg dbgen.CreateRunParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.CreateRunParams
	}
	mock.lockCreateRun.RLock()
	calls = mock.calls.CreateRun
	mock.lockCreateRun.RUnlock()
	return calls
}

// CreateTask calls CreateTaskFunc.
func (mock *StoreMock) CreateTask(ctx context.Context, arg dbgen.CreateTaskParams) (pgtype.UUID, error) {
	if mock.CreateTaskFunc == nil {
		panic("StoreMock.CreateTaskFunc: method is nil but Store.CreateTask was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.CreateTaskParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockCreateTask.Lock()
	mock.calls.CreateTask = append(mock.calls.CreateTask, callInfo)
	mock.lockCreateTask.Unlock()
	return mock.CreateTaskFunc(ctx, arg)
}

// CreateTaskCalls gets all the calls that were made to CreateTask.
// Check the length with:
//
//	len(mockedStore.CreateTaskCalls())
func (mock *StoreMock) CreateTaskCalls() []struct {
	Ctx context.Context
	Arg dbgen.CreateTaskParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.CreateTaskParams
	}
	mock.lockCreateTask.RLock()
	calls = mock.calls.CreateTask
	mock.lockCreateTask.RUnlock()
	return calls
}

// CreateWorkflowRun calls CreateWorkflowRunFunc.
func (mock *StoreMock) CreateWorkflowRun(ctx context.Context, arg dbgen.CreateWorkflowRunParams) (dbgen.WorkflowRun, error) {
	if mock.CreateWorkflowRunFunc == nil {
		panic("StoreMock.CreateWorkflowRunFunc: method is nil but Store.CreateWorkflowRun was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.CreateWorkflowRunParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockCreateWorkflowRun.Lock()
	mock.calls.CreateWorkflowRun = append(mock.calls.CreateWorkflowRun, callInfo)
	mock.lockCreateWorkflowRun.Unlock()
	return mock.CreateWorkflowRunFunc(ctx, arg)
}

// CreateWorkflowRunCalls gets all the calls that were made to CreateWorkflowRun.
// Check the length with:
//
//	len(mockedStore.CreateWorkflowRunCalls())
func (mock *StoreMock) CreateWorkflowRunCalls() []struct {
	Ctx context.Context
	Arg dbgen.CreateWorkflowRunParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.CreateWorkflowRunParams
	}
	mock.lockCreateWorkflowRun.RLock()
	calls = mock.calls.CreateWorkflowRun
	mock.lockCreateWorkflowRun.RUnlock()
	return calls
}

// DeleteQueue calls DeleteQueueFunc.
func (mock *StoreMock) DeleteQueue(ctx context.Context, id pgtype.UUID) error {
	if mock.DeleteQueueFunc == nil {
		panic("StoreMock.DeleteQueueFunc: method is nil but Store.DeleteQueue was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteQueue.Lock()
	mock.calls.DeleteQueue = append(mock.calls.DeleteQueue, callInfo)
	mock.lockDeleteQueue.Unlock()
	return mock.DeleteQueueFunc(ctx, id)
}

// DeleteQueueCalls gets all the calls that were made to DeleteQueue.
// Check the length with:
//
//	len(mockedStore.DeleteQueueCalls())
func (mock *StoreMock) DeleteQueueCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockDeleteQueue.RLock()
	calls = mock.calls.DeleteQueue
	mock.lockDeleteQueue.RUnlock()
	return calls
}

// ExecTx calls ExecTxFunc.
func (mock *StoreMock) ExecTx(ctx context.Context, fn func(dbgen.Querier) error) error {
	if mock.ExecTxFunc == nil {
		panic("StoreMock.ExecTxFunc: method is nil but Store.ExecTx was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Fn  func(dbgen.Querier) error
	}{
		Ctx: ctx,
		Fn:  fn,
	}
	mock.lockExecTx.Lock()
	mock.calls.ExecTx = append(mock.calls.ExecTx, callInfo)
	mock.lockExecTx.Unlock()
	return mock.ExecTxFunc(ctx, fn)
}

// ExecTxCalls gets all the calls that were made to ExecTx.
// Check the length with:
//
//	len(mockedStore.ExecTxCalls())
func (mock *StoreMock) ExecTxCalls() []struct {
	Ctx context.Context
	Fn  func(dbgen.Querier) error
} {
	var calls []struct {
		Ctx context.Context
		Fn  func(dbgen.Querier) error
	}
	mock.lockExecTx.RLock()
	calls = mock.calls.ExecTx
	mock.lockExecTx.RUnlock()
	return calls
}

// ExpireTimedOutWaiters calls ExpireTimedOutWaitersFunc.
func (mock *StoreMock) ExpireTimedOutWaiters(ctx context.Context) ([]dbgen.Run, error) {
	if mock.ExpireTimedOutWaitersFunc == nil {
		panic("StoreMock.ExpireTimedOutWaitersFunc: method is nil but Store.ExpireTimedOutWaiters was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockExpireTimedOutWaiters.Lock()
	mock.calls.ExpireTimedOutWaiters = append(mock.calls.ExpireTimedOutWaiters, callInfo)
	mock.lockExpireTimedOutWaiters.Unlock()
	return mock.ExpireTimedOutWaitersFunc(ctx)
}

// ExpireTimedOutWaitersCalls gets all the calls that were made to ExpireTimedOutWaiters.
// Check the length with:
//
//	len(mockedStore.ExpireTimedOutWaitersCalls())
func (mock *StoreMock) ExpireTimedOutWaitersCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockExpireTimedOutWaiters.RLock()
	calls = mock.calls.ExpireTimedOutWaiters
	mock.lockExpireTimedOutWaiters.RUnlock()
	return calls
}

// ExtendRunClaim calls ExtendRunClaimFunc.
func (mock *StoreMock) ExtendRunClaim(ctx context.Context, arg dbgen.ExtendRunClaimParams) error {
	if mock.ExtendRunClaimFunc == nil {
		panic("StoreMock.ExtendRunClaimFunc: method is nil but Store.ExtendRunClaim was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.ExtendRunClaimParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockExtendRunClaim.Lock()
	mock.calls.ExtendRunClaim = append(mock.calls.ExtendRunClaim, callInfo)
	mock.lockExtendRunClaim.Unlock()
	return mock.ExtendRunClaimFunc(ctx, arg)
}

// ExtendRunClaimCalls gets all the calls that were made to ExtendRunClaim.
// Check the length with:
//
//	len(mockedStore.ExtendRunClaimCalls())
func (mock *StoreMock) ExtendRunClaimCalls() []struct {
	Ctx context.Context
	Arg dbgen.ExtendRunClaimParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.ExtendRunClaimParams
	}
	mock.lockExtendRunClaim.RLock()
	calls = mock.calls.ExtendRunClaim
	mock.lockExtendRunClaim.RUnlock()
	return calls
}

// FailRun calls FailRunFunc.
func (mock *StoreMock) FailRun(ctx context.Context, arg dbgen.FailRunParams) error {
	if mock.FailRunFunc == nil {
		panic("StoreMock.FailRunFunc: method is nil but Store.FailRun was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.FailRunParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockFailRun.Lock()
	mock.calls.FailRun = append(mock.calls.FailRun, callInfo)
	mock.lockFailRun.Unlock()
	return mock.FailRunFunc(ctx, arg)
}

// FailRunCalls gets all the calls that were made to FailRun.
// Check the length with:
//
//	len(mockedStore.FailRunCalls())
func (mock *StoreMock) FailRunCalls() []struct {
	Ctx context.Context
	Arg dbgen.FailRunParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.FailRunParams
	}
	mock.lockFailRun.RLock()
	calls = mock.calls.FailRun
	mock.lockFailRun.RUnlock()
	return calls
}

// GetCheckpoint calls GetCheckpointFunc.
func (mock *StoreMock) GetCheckpoint(ctx context.Context, arg dbgen.GetCheckpointParams) (dbgen.Checkpoint, error) {
	if mock.GetCheckpointFunc == nil {
		panic("StoreMock.GetCheckpointFunc: method is nil but Store.GetCheckpoint was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.GetCheckpointParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockGetCheckpoint.Lock()
	mock.calls.GetCheckpoint = append(mock.calls.GetCheckpoint, callInfo)
	mock.lockGetCheckpoint.Unlock()
	return mock.GetCheckpointFunc(ctx, arg)
}

// GetCheckpointCalls gets all the calls that were made to GetCheckpoint.
// Check the length with:
//
//	len(mockedStore.GetCheckpointCalls())
func (mock *StoreMock) GetCheckpointCalls() []struct {
	Ctx context.Context
	Arg dbgen.GetCheckpointParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.GetCheckpointParams
	}
	mock.lockGetCheckpoint.RLock()
	calls = mock.calls.GetCheckpoint
	mock.lockGetCheckpoint.RUnlock()
	return calls
}

// GetEventByName calls GetEventByNameFunc.
func (mock *StoreMock) GetEventByName(ctx context.Context, eventName string) (dbgen.Event, error) {
	if mock.GetEventByNameFunc == nil {
		panic("StoreMock.GetEventByNameFunc: method is nil but Store.GetEventByName was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		EventName string
	}{
		Ctx:       ctx,
		EventName: eventName,
	}
	mock.lockGetEventByName.Lock()
	mock.calls.GetEventByName = append(mock.calls.GetEventByName, callInfo)
	mock.lockGetEventByName.Unlock()
	return mock.GetEventByNameFunc(ctx, eventName)
}

// GetEventByNameCalls gets all the calls that were made to GetEventByName.
// Check the length with:
//
//	len(mockedStore.GetEventByNameCalls())
func (mock *StoreMock) GetEventByNameCalls() []struct {
	Ctx       context.Context
	EventName string
} {
	var calls []struct {
		Ctx       context.Context
		EventName string
	}
	mock.lockGetEventByName.RLock()
	calls = mock.calls.GetEventByName
	mock.lockGetEventByName.RUnlock()
	return calls
}

// GetQueueByName calls GetQueueByNameFunc.
func (mock *StoreMock) GetQueueByName(ctx context.Context, name string) (dbgen.Queue, error) {
	if mock.GetQueueByNameFunc == nil {
		panic("StoreMock.GetQueueByNameFunc: method is nil but Store.GetQueueByName was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockGetQueueByName.Lock()
	mock.calls.GetQueueByName = append(mock.calls.GetQueueByName, callInfo)
	mock.lockGetQueueByName.Unlock()
	return mock.GetQueueByNameFunc(ctx, name)
}

// GetQueueByNameCalls gets all the calls that were made to GetQueueByName.
// Check the length with:
//
//	len(mockedStore.GetQueueByNameCalls())
func (mock *StoreMock) GetQueueByNameCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockGetQueueByName.RLock()
	calls = mock.calls.GetQueueByName
	mock.lockGetQueueByName.RUnlock()
	return calls
}

// GetQueueStats calls GetQueueStatsFunc.
func (mock *StoreMock) GetQueueStats(ctx context.Context, queueID pgtype.UUID) (dbgen.GetQueueStatsRow, error) {
	if mock.GetQueueStatsFunc == nil {
		panic("StoreMock.GetQueueStatsFunc: method is nil but Store.GetQueueStats was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		QueueID pgtype.UUID
	}{
		Ctx:     ctx,
		QueueID: queueID,
	}
	mock.lockGetQueueStats.Lock()
	mock.calls.GetQueueStats = append(mock.calls.GetQueueStats, callInfo)
	mock.lockGetQueueStats.Unlock()
	return mock.GetQueueStatsFunc(ctx, queueID)
}

// GetQueueStatsCalls gets all the calls that were made to GetQueueStats.
// Check the length with:
//
//	len(mockedStore.GetQueueStatsCalls())
func (mock *StoreMock) GetQueueStatsCalls() []struct {
	Ctx     context.Context
	QueueID pgtype.UUID
} {
	var calls []struct {
		Ctx     context.Context
		QueueID pgtype.UUID
	}
	mock.lockGetQueueStats.RLock()
	calls = mock.calls.GetQueueStats
	mock.lockGetQueueStats.RUnlock()
	return calls
}

// GetRun calls GetRunFunc.
func (mock *StoreMock) GetRun(ctx context.Context, id pgtype.UUID) (dbgen.Run, error) {
	if mock.GetRunFunc == nil {
		panic("StoreMock.GetRunFunc: method is nil but Store.GetRun was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetRun.Lock()
	mock.calls.GetRun = append(mock.calls.GetRun, callInfo)
	mock.lockGetRun.Unlock()
	return mock.GetRunFunc(ctx, id)
}

// GetRunCalls gets all the calls that were made to GetRun.
// Check the length with:
//
//	len(mockedStore.GetRunCalls())
func (mock *StoreMock) GetRunCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockGetRun.RLock()
	calls = mock.calls.GetRun
	mock.lockGetRun.RUnlock()
	return calls
}

// GetRunsByTask calls GetRunsByTaskFunc.
func (mock *StoreMock) GetRunsByTask(ctx context.Context, taskID pgtype.UUID) ([]dbgen.Run, error) {
	if mock.GetRunsByTaskFunc == nil {
		panic("StoreMock.GetRunsByTaskFunc: method is nil but Store.GetRunsByTask was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		TaskID pgtype.UUID
	}{
		Ctx:    ctx,
		TaskID: taskID,
	}
	mock.lockGetRunsByTask.Lock()
	mock.calls.GetRunsByTask = append(mock.calls.GetRunsByTask, callInfo)
	mock.lockGetRunsByTask.Unlock()
	return mock.GetRunsByTaskFunc(ctx, taskID)
}

// GetRunsByTaskCalls gets all the calls that were made to GetRunsByTask.
// Check the length with:
//
//	len(mockedStore.GetRunsByTaskCalls())
func (mock *StoreMock) GetRunsByTaskCalls() []struct {
	Ctx    context.Context
	TaskID pgtype.UUID
} {
	var calls []struct {
		Ctx    context.Context
		TaskID pgtype.UUID
	}
	mock.lockGetRunsByTask.RLock()
	calls = mock.calls.GetRunsByTask
	mock.lockGetRunsByTask.RUnlock()
	return calls
}

// GetTask calls GetTaskFunc.
func (mock *StoreMock) GetTask(ctx context.Context, id pgtype.UUID) (dbgen.Task, error) {
	if mock.GetTaskFunc == nil {
		panic("StoreMock.GetTaskFunc: method is nil but Store.GetTask was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetTask.Lock()
	mock.calls.GetTask = append(mock.calls.GetTask, callInfo)
	mock.lockGetTask.Unlock()
	return mock.GetTaskFunc(ctx, id)
}

// GetTaskCalls gets all the calls that were made to GetTask.
// Check the length with:
//
//	len(mockedStore.GetTaskCalls())
func (mock *StoreMock) GetTaskCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockGetTask.RLock()
	calls = mock.calls.GetTask
	mock.lockGetTask.RUnlock()
	return calls
}

// GetWorkflowRun calls GetWorkflowRunFunc.
func (mock *StoreMock) GetWorkflowRun(ctx context.Context, id pgtype.UUID) (dbgen.WorkflowRun, error) {
	if mock.GetWorkflowRunFunc == nil {
		panic("StoreMock.GetWorkflowRunFunc: method is nil but Store.GetWorkflowRun was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetWorkflowRun.Lock()
	mock.calls.GetWorkflowRun = append(mock.calls.GetWorkflowRun, callInfo)
	mock.lockGetWorkflowRun.Unlock()
	return mock.GetWorkflowRunFunc(ctx, id)
}

// GetWorkflowRunCalls gets all the calls that were made to GetWorkflowRun.
// Check the length with:
//
//	len(mockedStore.GetWorkflowRunCalls())
func (mock *StoreMock) GetWorkflowRunCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockGetWorkflowRun.RLock()
	calls = mock.calls.GetWorkflowRun
	mock.lockGetWorkflowRun.RUnlock()
	return calls
}

// ListQueues calls ListQueuesFunc.
func (mock *StoreMock) ListQueues(ctx context.Context) ([]dbgen.Queue, error) {
	if mock.ListQueuesFunc == nil {
		panic("StoreMock.ListQueuesFunc: method is nil but Store.ListQueues was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListQueues.Lock()
	mock.calls.ListQueues = append(mock.calls.ListQueues, callInfo)
	mock.lockListQueues.Unlock()
	return mock.ListQueuesFunc(ctx)
}

// ListQueuesCalls gets all the calls that were made to ListQueues.
// Check the length with:
//
//	len(mockedStore.ListQueuesCalls())
func (mock *StoreMock) ListQueuesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListQueues.RLock()
	calls = mock.calls.ListQueues
	mock.lockListQueues.RUnlock()
	return calls
}

// ListTasks calls ListTasksFunc.
func (mock *StoreMock) ListTasks(ctx context.Context, arg dbgen.ListTasksParams) ([]dbgen.ListTasksRow, error) {
	if mock.ListTasksFunc == nil {
		panic("StoreMock.ListTasksFunc: method is nil but Store.ListTasks was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.ListTasksParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockListTasks.Lock()
	mock.calls.ListTasks = append(mock.calls.ListTasks, callInfo)
	mock.lockListTasks.Unlock()
	return mock.ListTasksFunc(ctx, arg)
}

// ListTasksCalls gets all the calls that were made to ListTasks.
// Check the length with:
//
//	len(mockedStore.ListTasksCalls())
func (mock *StoreMock) ListTasksCalls() []struct {
	Ctx context.Context
	Arg dbgen.ListTasksParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.ListTasksParams
	}
	mock.lockListTasks.RLock()
	calls = mock.calls.ListTasks
	mock.lockListTasks.RUnlock()
	return calls
}

// ScheduleRun calls ScheduleRunFunc.
func (mock *StoreMock) ScheduleRun(ctx context.Context, arg dbgen.ScheduleRunParams) error {
	if mock.ScheduleRunFunc == nil {
		panic("StoreMock.ScheduleRunFunc: method is nil but Store.ScheduleRun was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.ScheduleRunParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockScheduleRun.Lock()
	mock.calls.ScheduleRun = append(mock.calls.ScheduleRun, callInfo)
	mock.lockScheduleRun.Unlock()
	return mock.ScheduleRunFunc(ctx, arg)
}

// ScheduleRunCalls gets all the calls that were made to ScheduleRun.
// Check the length with:
//
//	len(mockedStore.ScheduleRunCalls())
func (mock *StoreMock) ScheduleRunCalls() []struct {
	Ctx context.Context
	Arg dbgen.ScheduleRunParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.ScheduleRunParams
	}
	mock.lockScheduleRun.RLock()
	calls = mock.calls.ScheduleRun
	mock.lockScheduleRun.RUnlock()
	return calls
}

// SetRunSleeping calls SetRunSleepingFunc.
func (mock *StoreMock) SetRunSleeping(ctx context.Context, arg dbgen.SetRunSleepingParams) error {
	if mock.SetRunSleepingFunc == nil {
		panic("StoreMock.SetRunSleepingFunc: method is nil but Store.SetRunSleeping was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.SetRunSleepingParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockSetRunSleeping.Lock()
	mock.calls.SetRunSleeping = append(mock.calls.SetRunSleeping, callInfo)
	mock.lockSetRunSleeping.Unlock()
	return mock.SetRunSleepingFunc(ctx, arg)
}

// SetRunSleepingCalls gets all the calls that were made to SetRunSleeping.
// Check the length with:
//
//	len(mockedStore.SetRunSleepingCalls())
func (mock *StoreMock) SetRunSleepingCalls() []struct {
	Ctx context.Context
	Arg dbgen.SetRunSleepingParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.SetRunSleepingParams
	}
	mock.lockSetRunSleeping.RLock()
	calls = mock.calls.SetRunSleeping
	mock.lockSetRunSleeping.RUnlock()
	return calls
}

// UpdateTaskStatus calls UpdateTaskStatusFunc.
func (mock *StoreMock) UpdateTaskStatus(ctx context.Context, arg dbgen.UpdateTaskStatusParams) error {
	if mock.UpdateTaskStatusFunc == nil {
		panic("StoreMock.UpdateTaskStatusFunc: method is nil but Store.UpdateTaskStatus was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.UpdateTaskStatusParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateTaskStatus.Lock()
	mock.calls.UpdateTaskStatus = append(mock.calls.UpdateTaskStatus, callInfo)
	mock.lockUpdateTaskStatus.Unlock()
	return mock.UpdateTaskStatusFunc(ctx, arg)
}

// UpdateTaskStatusCalls gets all the calls that were made to UpdateTaskStatus.
// Check the length with:
//
//	len(mockedStore.UpdateTaskStatusCalls())
func (mock *StoreMock) UpdateTaskStatusCalls() []struct {
	Ctx context.Context
	Arg dbgen.UpdateTaskStatusParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.UpdateTaskStatusParams
	}
	mock.lockUpdateTaskStatus.RLock()
	calls = mock.calls.UpdateTaskStatus
	mock.lockUpdateTaskStatus.RUnlock()
	return calls
}

// UpdateWorkflowRun calls UpdateWorkflowRunFunc.
func (mock *StoreMock) UpdateWorkflowRun(ctx context.Context, arg dbgen.UpdateWorkflowRunParams) (dbgen.WorkflowRun, error) {
	if mock.UpdateWorkflowRunFunc == nil {
		panic("StoreMock.UpdateWorkflowRunFunc: method is nil but Store.UpdateWorkflowRun was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.UpdateWorkflowRunParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateWorkflowRun.Lock()
	mock.calls.UpdateWorkflowRun = append(mock.calls.UpdateWorkflowRun, callInfo)
	mock.lockUpdateWorkflowRun.Unlock()
	return mock.UpdateWorkflowRunFunc(ctx, arg)
}

// UpdateWorkflowRunCalls gets all the calls that were made to UpdateWorkflowRun.
// Check the length with:
//
//	len(mockedStore.UpdateWorkflowRunCalls())
func (mock *StoreMock) UpdateWorkflowRunCalls() []struct {
	Ctx context.Context
	Arg dbgen.UpdateWorkflowRunParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.UpdateWorkflowRunParams
	}
	mock.lockUpdateWorkflowRun.RLock()
	calls = mock.calls.UpdateWorkflowRun
	mock.lockUpdateWorkflowRun.RUnlock()
	return calls
}

// UpsertCheckpoint calls UpsertCheckpointFunc.
func (mock *StoreMock) UpsertCheckpoint(ctx context.Context, arg dbgen.UpsertCheckpointParams) (dbgen.Checkpoint, error) {
	if mock.UpsertCheckpointFunc == nil {
		panic("StoreMock.UpsertCheckpointFunc: method is nil but Store.UpsertCheckpoint was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg dbgen.UpsertCheckpointParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpsertCheckpoint.Lock()
	mock.calls.UpsertCheckpoint = append(mock.calls.UpsertCheckpoint, callInfo)
	mock.lockUpsertCheckpoint.Unlock()
	return mock.UpsertCheckpointFunc(ctx, arg)
}

// UpsertCheckpointCalls gets all the calls that were made to UpsertCheckpoint.
// Check the length with:
//
//	len(mockedStore.UpsertCheckpointCalls())
func (mock *StoreMock) UpsertCheckpointCalls() []struct {
	Ctx context.Context
	Arg dbgen.UpsertCheckpointParams
} {
	var calls []struct {
		Ctx context.Context
		Arg dbgen.UpsertCheckpointParams
	}
	mock.lockUpsertCheckpoint.RLock()
	calls = mock.calls.UpsertCheckpoint
	mock.lockUpsertCheckpoint.RUnlock()
	return calls
}

// WakeRunsByEvent calls WakeRunsByEventFunc.
func (mock *StoreMock) WakeRunsByEvent(ctx context.Context, waitingEventName pgtype.Text) ([]dbgen.Run, error) {
	if mock.WakeRunsByEventFunc == nil {
		panic("StoreMock.WakeRunsByEventFunc: method is nil but Store.WakeRunsByEvent was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		WaitingEventName pgtype.Text
	}{
		Ctx:              ctx,
		WaitingEventName: waitingEventName,
	}
	mock.lockWakeRunsByEvent.Lock()
	mock.calls.WakeRunsByEvent = append(mock.calls.WakeRunsByEvent, callInfo)
	mock.lockWakeRunsByEvent.Unlock()
	return mock.WakeRunsByEventFunc(ctx, waitingEventName)
}

// WakeRunsByEventCalls gets all the calls that were made to WakeRunsByEvent.
// Check the length with:
//
//	len(mockedStore.WakeRunsByEventCalls())
func (mock *StoreMock) WakeRunsByEventCalls() []struct {
	Ctx              context.Context
	WaitingEventName pgtype.Text
} {
	var calls []struct {
		Ctx              context.Context
		WaitingEventName pgtype.Text
	}
	mock.lockWakeRunsByEvent.RLock()
	calls = mock.calls.WakeRunsByEvent
	mock.lockWakeRunsByEvent.RUnlock()
	return calls
}
