// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: runs.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const claimRuns = `-- name: ClaimRuns :many
UPDATE runs
SET status = 'claimed',
    claimed_at = now(),
    claim_expires_at = now() + make_interval(secs => $1::int)
WHERE id IN (
    SELECT r.id
    FROM runs r
    JOIN tasks t ON t.id = r.task_id
    WHERE t.queue_id = $2
      AND (
          r.status = 'pending'
          OR (r.status = 'claimed' AND r.claim_expires_at <= now())
      )
      AND (r.scheduled_at IS NULL OR r.scheduled_at <= now())
    ORDER BY r.created_at ASC
    FOR UPDATE OF r SKIP LOCKED
    LIMIT $3
)
RETURNING runs.id, runs.task_id, runs.attempt, runs.status, runs.result, runs.error, runs.claimed_at, runs.claim_expires_at, runs.scheduled_at, runs.waiting_event_name, runs.waiting_step_name, runs.waiting_timeout_at, runs.created_at, runs.completed_at,
    (SELECT t.task_name FROM tasks t WHERE t.id = runs.task_id) AS task_name,
    (SELECT t.params FROM tasks t WHERE t.id = runs.task_id) AS task_params,
    (SELECT t.headers FROM tasks t WHERE t.id = runs.task_id) AS task_headers,
    (SELECT t.retry_strategy FROM tasks t WHERE t.id = runs.task_id) AS task_retry_strategy,
    (SELECT t.max_attempts FROM tasks t WHERE t.id = runs.task_id) AS task_max_attempts
`

type ClaimRunsParams struct {
	ClaimTimeoutSeconds int32       `json:"claim_timeout_seconds"`
	QueueID             pgtype.UUID `json:"queue_id"`
	Num                 int32       `json:"num"`
}

type ClaimRunsRow struct {
	ID                pgtype.UUID        `json:"id"`
	TaskID            pgtype.UUID        `json:"task_id"`
	Attempt           int32              `json:"attempt"`
	Status            RunStatus          `json:"status"`
	Result            []byte             `json:"result"`
	Error             pgtype.Text        `json:"error"`
	ClaimedAt         pgtype.Timestamptz `json:"claimed_at"`
	ClaimExpiresAt    pgtype.Timestamptz `json:"claim_expires_at"`
	ScheduledAt       pgtype.Timestamptz `json:"scheduled_at"`
	WaitingEventName  pgtype.Text        `json:"waiting_event_name"`
	WaitingStepName   pgtype.Text        `json:"waiting_step_name"`
	WaitingTimeoutAt  pgtype.Timestamptz `json:"waiting_timeout_at"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	CompletedAt       pgtype.Timestamptz `json:"completed_at"`
	TaskName          string             `json:"task_name"`
	TaskParams        []byte             `json:"task_params"`
	TaskHeaders       []byte             `json:"task_headers"`
	TaskRetryStrategy []byte             `json:"task_retry_strategy"`
	TaskMaxAttempts   int32              `json:"task_max_attempts"`
}

func (q *Queries) ClaimRuns(ctx context.Context, arg ClaimRunsParams) ([]ClaimRunsRow, error) {
	rows, err := q.db.Query(ctx, claimRuns, arg.ClaimTimeoutSeconds, arg.QueueID, arg.Num)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ClaimRunsRow{}
	for rows.Next() {
		var i ClaimRunsRow
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Attempt,
			&i.Status,
			&i.Result,
			&i.Error,
			&i.ClaimedAt,
			&i.ClaimExpiresAt,
			&i.ScheduledAt,
			&i.WaitingEventName,
			&i.WaitingStepName,
			&i.WaitingTimeoutAt,
			&i.CreatedAt,
			&i.CompletedAt,
			&i.TaskName,
			&i.TaskParams,
			&i.TaskHeaders,
			&i.TaskRetryStrategy,
			&i.TaskMaxAttempts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cleanupCompletedRuns = `-- name: CleanupCompletedRuns :exec
DELETE FROM runs
WHERE status IN ('completed', 'failed')
  AND completed_at < now() - make_interval(secs => $1::int)
`

func (q *Queries) CleanupCompletedRuns(ctx context.Context, ttlSeconds int32) error {
	_, err := q.db.Exec(ctx, cleanupCompletedRuns, ttlSeconds)
	return err
}

const completeRun = `-- name: CompleteRun :exec
UPDATE runs
SET status = 'completed', result = $2, completed_at = now()
WHERE id = $1
`

type CompleteRunParams struct {
	ID     pgtype.UUID `json:"id"`
	Result []byte      `json:"result"`
}

func (q *Queries) CompleteRun(ctx context.Context, arg CompleteRunParams) error {
	_, err := q.db.Exec(ctx, completeRun, arg.ID, arg.Result)
	return err
}

const createRun = `-- name: CreateRun :one
INSERT INTO runs (task_id, attempt, scheduled_at)
VALUES ($1, $2, $3)
RETURNING id, task_id, attempt, status, result, error, claimed_at, claim_expires_at, scheduled_at, waiting_event_name, waiting_step_name, waiting_timeout_at, created_at, completed_at
`

type CreateRunParams struct {
	TaskID      pgtype.UUID        `json:"task_id"`
	Attempt     int32              `json:"attempt"`
	ScheduledAt pgtype.Timestamptz `json:"scheduled_at"`
}

func (q *Queries) CreateRun(ctx context.Context, arg CreateRunParams) (Run, error) {
	row := q.db.QueryRow(ctx, createRun, arg.TaskID, arg.Attempt, arg.ScheduledAt)
	var i Run
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Attempt,
		&i.Status,
		&i.Result,
		&i.Error,
		&i.ClaimedAt,
		&i.ClaimExpiresAt,
		&i.ScheduledAt,
		&i.WaitingEventName,
		&i.WaitingStepName,
		&i.WaitingTimeoutAt,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const expireTimedOutWaiters = `-- name: ExpireTimedOutWaiters :many
UPDATE runs
SET status = 'failed', error = 'wait timeout expired', completed_at = now()
WHERE status = 'sleeping' AND waiting_timeout_at <= now()
RETURNING id, task_id, attempt, status, result, error, claimed_at, claim_expires_at, scheduled_at, waiting_event_name, waiting_step_name, waiting_timeout_at, created_at, completed_at
`

func (q *Queries) ExpireTimedOutWaiters(ctx context.Context) ([]Run, error) {
	rows, err := q.db.Query(ctx, expireTimedOutWaiters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Run{}
	for rows.Next() {
		var i Run
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Attempt,
			&i.Status,
			&i.Result,
			&i.Error,
			&i.ClaimedAt,
			&i.ClaimExpiresAt,
			&i.ScheduledAt,
			&i.WaitingEventName,
			&i.WaitingStepName,
			&i.WaitingTimeoutAt,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const failRun = `-- name: FailRun :exec
UPDATE runs
SET status = 'failed', error = $2, completed_at = now()
WHERE id = $1
`

type FailRunParams struct {
	ID    pgtype.UUID `json:"id"`
	Error pgtype.Text `json:"error"`
}

func (q *Queries) FailRun(ctx context.Context, arg FailRunParams) error {
	_, err := q.db.Exec(ctx, failRun, arg.ID, arg.Error)
	return err
}

const getRun = `-- name: GetRun :one
SELECT id, task_id, attempt, status, result, error, claimed_at, claim_expires_at, scheduled_at, waiting_event_name, waiting_step_name, waiting_timeout_at, created_at, completed_at FROM runs WHERE id = $1
`

func (q *Queries) GetRun(ctx context.Context, id pgtype.UUID) (Run, error) {
	row := q.db.QueryRow(ctx, getRun, id)
	var i Run
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Attempt,
		&i.Status,
		&i.Result,
		&i.Error,
		&i.ClaimedAt,
		&i.ClaimExpiresAt,
		&i.ScheduledAt,
		&i.WaitingEventName,
		&i.WaitingStepName,
		&i.WaitingTimeoutAt,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getRunsByTask = `-- name: GetRunsByTask :many
SELECT id, task_id, attempt, status, result, error, claimed_at, claim_expires_at, scheduled_at, waiting_event_name, waiting_step_name, waiting_timeout_at, created_at, completed_at FROM runs WHERE task_id = $1 ORDER BY attempt ASC
`

func (q *Queries) GetRunsByTask(ctx context.Context, taskID pgtype.UUID) ([]Run, error) {
	rows, err := q.db.Query(ctx, getRunsByTask, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Run{}
	for rows.Next() {
		var i Run
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Attempt,
			&i.Status,
			&i.Result,
			&i.Error,
			&i.ClaimedAt,
			&i.ClaimExpiresAt,
			&i.ScheduledAt,
			&i.WaitingEventName,
			&i.WaitingStepName,
			&i.WaitingTimeoutAt,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const scheduleRun = `-- name: ScheduleRun :exec
UPDATE runs
SET scheduled_at = $2
WHERE id = $1
`

type ScheduleRunParams struct {
	ID          pgtype.UUID        `json:"id"`
	ScheduledAt pgtype.Timestamptz `json:"scheduled_at"`
}

func (q *Queries) ScheduleRun(ctx context.Context, arg ScheduleRunParams) error {
	_, err := q.db.Exec(ctx, scheduleRun, arg.ID, arg.ScheduledAt)
	return err
}

const setRunSleeping = `-- name: SetRunSleeping :exec
UPDATE runs
SET status = 'sleeping',
    waiting_event_name = $2,
    waiting_step_name = $3,
    waiting_timeout_at = $4
WHERE id = $1
`

type SetRunSleepingParams struct {
	ID               pgtype.UUID        `json:"id"`
	WaitingEventName pgtype.Text        `json:"waiting_event_name"`
	WaitingStepName  pgtype.Text        `json:"waiting_step_name"`
	WaitingTimeoutAt pgtype.Timestamptz `json:"waiting_timeout_at"`
}

func (q *Queries) SetRunSleeping(ctx context.Context, arg SetRunSleepingParams) error {
	_, err := q.db.Exec(ctx, setRunSleeping,
		arg.ID,
		arg.WaitingEventName,
		arg.WaitingStepName,
		arg.WaitingTimeoutAt,
	)
	return err
}

const wakeRunsByEvent = `-- name: WakeRunsByEvent :many
UPDATE runs
SET status = 'pending',
    waiting_event_name = NULL,
    waiting_step_name = NULL,
    waiting_timeout_at = NULL
WHERE status = 'sleeping' AND waiting_event_name = $1
RETURNING id, task_id, attempt, status, result, error, claimed_at, claim_expires_at, scheduled_at, waiting_event_name, waiting_step_name, waiting_timeout_at, created_at, completed_at
`

func (q *Queries) WakeRunsByEvent(ctx context.Context, waitingEventName pgtype.Text) ([]Run, error) {
	rows, err := q.db.Query(ctx, wakeRunsByEvent, waitingEventName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Run{}
	for rows.Next() {
		var i Run
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Attempt,
			&i.Status,
			&i.Result,
			&i.Error,
			&i.ClaimedAt,
			&i.ClaimExpiresAt,
			&i.ScheduledAt,
			&i.WaitingEventName,
			&i.WaitingStepName,
			&i.WaitingTimeoutAt,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
